--[[
    å¸½å­ç”©é£ & ç¢°æ’ç‹¬ç«‹æ¨¡å—ï¼ˆå…¼å®¹ç‰ˆï¼‰
    ä¿®å¤ï¼šå¢åŠ å‡½æ•°å­˜åœ¨æ€§æ£€æŸ¥ï¼Œæä¾›é”™è¯¯åé¦ˆ
]]

if _G.HatFlingLoaded then 
    game:GetService("StarterGui"):SetCore("SendNotification", {Title="æç¤º", Text="å¸½å­åˆ†èº«å·²åŠ è½½ï¼Œæ— éœ€é‡å¤æ‰§è¡Œ"})
    return 
end
_G.HatFlingLoaded = true

-- ========== ç¯å¢ƒå…¼å®¹å±‚ ==========
local function safeRequire(funcName, defaultValue)
    local ok, result = pcall(function() return _G[funcName] end)
    if ok and result then return result end
    ok, result = pcall(function() return getfenv()[funcName] end)
    if ok and result then return result end
    return defaultValue
end

local cloneref = safeRequire("cloneref") or function(o) return o end
local getcustomasset = safeRequire("getcustomasset") or safeRequire("getsynasset") or function(p) return "" end
local gethiddengui = safeRequire("gethiddengui") or function() return cloneref(game:GetService("CoreGui")) end
local isfile = safeRequire("isfile") or function(p) local s,e=pcall(readfile,p); return s and e~=nil end
local writefile = safeRequire("writefile") or function() end
local delfile = safeRequire("delfile") or function() end
local listfiles = safeRequire("listfiles") or function() return {} end
local replicatesignal = safeRequire("replicatesignal") -- å¯èƒ½ä¸å­˜åœ¨
local sethiddenproperty = safeRequire("sethiddenproperty")
local isnetworkowner = safeRequire("isnetworkowner")

-- æœåŠ¡
local Debris = cloneref(game:GetService("Debris"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local TweenService = cloneref(game:GetService("TweenService"))
local HttpService = cloneref(game:GetService("HttpService"))
local TextService = cloneref(game:GetService("TextService"))
local StarterGui = cloneref(game:GetService("StarterGui"))
local Camera = workspace.CurrentCamera

local Player = Players.LocalPlayer
local FallenPartsDestroyHeight = workspace.FallenPartsDestroyHeight or -500

-- ========== å·¥å…·å‡½æ•° ==========
local Util = {}
Util.RandomString = function(l)
    l = l or 16
    local s = ""
    for _=1,l do s = s .. string.char(math.random(32,126)) end
    return s
end
Util.Notify = function(t)
    StarterGui:SetCore("SendNotification", {Title="å¸½å­åˆ†èº«", Text=t, Duration=5})
end
Util.Instance = function(c,p)
    local i = Instance.new(c)
    i.Name = Util.RandomString()
    i.Parent = p
    return i
end
Util.GetScreenSize = function()
    return Camera and Camera.ViewportSize or Vector2.new(512,512)
end
Util.IsGuiVisible = function(g)
    while g do
        if not g.Visible then return false end
        g = g.Parent
    end
    return true
end
Util.LinkDestroyI2C = function(a,b)
    a.Destroying:Once(function() b:Disconnect() end)
end
Util.LinkDestroyI2I = function(a,b)
    a.Destroying:Once(function() b:Destroy() end)
end

-- åˆ¤æ–­ç½‘ç»œæ‹¥æœ‰è€…ï¼ˆé™çº§ç‰ˆï¼‰
local function IsNetworkOwner(part)
    if isnetworkowner then
        local s,d = pcall(isnetworkowner, part)
        if s then return d end
    end
    -- å›é€€ï¼šå¦‚æœPartçš„ReceiveAgeä¸º0ï¼Œåˆ™å¯èƒ½æ˜¯æœ¬åœ°æ‹¥æœ‰
    local s,d = pcall(function() return part.ReceiveAge == 0 end)
    if s then return d end
    return false
end

-- ========== UIåˆ›å»º ==========
local HiddenGui = gethiddengui() or CoreGui
local ScreenGui = Util.Instance("ScreenGui", HiddenGui)
ScreenGui.Name = "HatFlingGUI"
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.DisplayOrder = 2147483647

local MainFrame = Util.Instance("Frame", ScreenGui)
MainFrame.AnchorPoint = Vector2.new(0.5,0.5)
MainFrame.Position = UDim2.new(0.5,0,0.5,0)
MainFrame.Size = UDim2.new(0,400,0,300)
MainFrame.BackgroundColor3 = Color3.new(0,0,0)
MainFrame.BackgroundTransparency = 0.1
MainFrame.BorderSizePixel = 1
MainFrame.BorderColor3 = Color3.new(1,1,1)
local UICorner = Util.Instance("UICorner", MainFrame)
UICorner.CornerRadius = UDim.new(0,8)

-- æ‹–åŠ¨
local dragToggle,dragStart,dragPos = false, nil, nil
MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragToggle = true
        dragStart = input.Position
        dragPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragToggle = false end
        end)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(dragPos.X.Scale, dragPos.X.Offset + delta.X, dragPos.Y.Scale, dragPos.Y.Offset + delta.Y)
    end
end)

-- ç¼©æ”¾
local resizeHandle = Util.Instance("Frame", MainFrame)
resizeHandle.AnchorPoint = Vector2.new(1,1)
resizeHandle.Position = UDim2.new(1,-10,1,-10)
resizeHandle.Size = UDim2.new(0,20,0,20)
resizeHandle.BackgroundColor3 = Color3.new(1,1,1)
resizeHandle.BackgroundTransparency = 0.5
resizeHandle.BorderSizePixel = 0
Util.Instance("UICorner", resizeHandle).CornerRadius = UDim.new(0,3)
local resizeStart, resizeSize
resizeHandle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        resizeStart = input.Position
        resizeSize = MainFrame.Size
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if resizeStart and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        local delta = input.Position - resizeStart
        MainFrame.Size = UDim2.new(0, math.max(300, resizeSize.X.Offset + delta.X), 0, math.max(200, resizeSize.Y.Offset + delta.Y))
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if resizeStart and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
        resizeStart = nil
    end
end)

-- æ ‡é¢˜
local TitleBar = Util.Instance("Frame", MainFrame)
TitleBar.Size = UDim2.new(1,0,0,30)
TitleBar.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
TitleBar.BorderSizePixel = 0
local TitleText = Util.Instance("TextLabel", TitleBar)
TitleText.AnchorPoint = Vector2.new(0,0.5)
TitleText.Position = UDim2.new(0,10,0.5,0)
TitleText.Size = UDim2.new(1,-40,1,0)
TitleText.BackgroundTransparency = 1
TitleText.Font = Enum.Font.GothamBold
TitleText.TextColor3 = Color3.new(1,1,1)
TitleText.TextSize = 18
TitleText.TextXAlignment = Enum.TextXAlignment.Left
TitleText.Text = "ğŸ© å¸½å­åˆ†èº«æ§åˆ¶"

local CloseBtn = Util.Instance("TextButton", TitleBar)
CloseBtn.AnchorPoint = Vector2.new(1,0.5)
CloseBtn.Position = UDim2.new(1,-10,0.5,0)
CloseBtn.Size = UDim2.new(0,20,0,20)
CloseBtn.BackgroundColor3 = Color3.new(1,0.3,0.3)
CloseBtn.Text = "X"
CloseBtn.TextColor3 = Color3.new(1,1,1)
CloseBtn.TextSize = 16
CloseBtn.BorderSizePixel = 0
Util.Instance("UICorner", CloseBtn).CornerRadius = UDim.new(0,3)
CloseBtn.MouseButton1Click:Connect(function() MainFrame.Visible = false end)

-- å†…å®¹åŒº
local Content = Util.Instance("Frame", MainFrame)
Content.AnchorPoint = Vector2.new(0.5,1)
Content.Position = UDim2.new(0.5,0,1,-5)
Content.Size = UDim2.new(1,-20,0,0)
Content.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
Content.BorderSizePixel = 0
Util.Instance("UICorner", Content).CornerRadius = UDim.new(0,5)
Content.AutomaticSize = Enum.AutomaticSize.Y

local UIList = Util.Instance("UIListLayout", Content)
UIList.Padding = UDim.new(0,5)
UIList.FillDirection = Enum.FillDirection.Vertical
UIList.HorizontalAlignment = Enum.HorizontalAlignment.Center

local function AddButton(text, callback)
    local btn = Util.Instance("TextButton", Content)
    btn.Size = UDim2.new(1,-10,0,35)
    btn.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
    btn.Text = text
    btn.TextColor3 = Color3.new(1,1,1)
    btn.TextSize = 16
    btn.BorderSizePixel = 0
    Util.Instance("UICorner", btn).CornerRadius = UDim.new(0,5)
    btn.MouseButton1Click:Connect(callback)
    return btn
end
local function AddSwitch(text, default, callback)
    local container = Util.Instance("Frame", Content)
    container.Size = UDim2.new(1,-10,0,35)
    container.BackgroundTransparency = 1
    local lbl = Util.Instance("TextLabel", container)
    lbl.AnchorPoint = Vector2.new(0,0.5)
    lbl.Position = UDim2.new(0,5,0.5,0)
    lbl.Size = UDim2.new(0.7,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = text
    lbl.TextColor3 = Color3.new(1,1,1)
    lbl.TextSize = 16
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local sw = Util.Instance("TextButton", container)
    sw.AnchorPoint = Vector2.new(1,0.5)
    sw.Position = UDim2.new(1,-5,0.5,0)
    sw.Size = UDim2.new(0,50,0,25)
    sw.BackgroundColor3 = default and Color3.new(0,1,0) or Color3.new(0.5,0.5,0.5)
    sw.Text = default and "ON" or "OFF"
    sw.TextColor3 = Color3.new(1,1,1)
    sw.TextSize = 14
    sw.BorderSizePixel = 0
    Util.Instance("UICorner", sw).CornerRadius = UDim.new(0,4)
    local state = default
    sw.MouseButton1Click:Connect(function()
        state = not state
        sw.BackgroundColor3 = state and Color3.new(0,1,0) or Color3.new(0.5,0.5,0.5)
        sw.Text = state and "ON" or "OFF"
        callback(state)
    end)
    return state
end

-- ========== æ ¸å¿ƒå¸½å­é‡åŠ¨ç”»æ¨¡å— ==========
local HatReanimator = {
    Enabled = false,
    Hats = {},
    FlingTargets = {},
    HatCollide = true,
    Permadeath = true,
    NetlessVelocity = 26,
    UseAngularVelocity = true,
    UsePatchmaLikeNetless = false,
    FollowMouse = true,
    ClumpCenter = nil,
}

-- è®¾ç½®AccoutrementçŠ¶æ€
local BackendAccoutrementState = {None=0, HasHandle=1, InWorkspace=2, InCharacter=3, Equipped=4}
local function SetAccoutrementState(acc, state)
    if sethiddenproperty then
        pcall(sethiddenproperty, acc, "BackendAccoutrementState", state)
    else
        pcall(function() acc.BackendAccoutrementState = state end)
    end
end

-- è·å–æ‰€æœ‰å¸½å­
local function GetAllHats()
    local hats = {}
    local char = Player.Character
    if char then
        for _,v in ipairs(char:GetChildren()) do
            if v:IsA("Accessory") then
                table.insert(hats, v)
            end
        end
    end
    return hats
end

-- è®¾ç½®å¸½å­CFrameï¼ˆnetlessç§»åŠ¨ï¼‰
local function SetHatCFrameNetless(handle, dt, targetCF, spin)
    if not (handle and handle:IsA("BasePart") and handle:IsDescendantOf(workspace)) then return false end
    if dt <= 0 then return false end
    local timing = os.clock()
    local idle = Vector3.new(math.sin(timing*14), math.sin(timing*15+1.0472), math.sin(timing*16+2.0944)) * 0.001
    if targetCF.Y < FallenPartsDestroyHeight+5 then
        targetCF = targetCF + Vector3.new(0, FallenPartsDestroyHeight+5 - targetCF.Y, 0)
    end
    local speedlimit = 16384
    local netless = HatReanimator.NetlessVelocity
    if not IsNetworkOwner(handle) then return false end
    pcall(sethiddenproperty, handle, "NetworkIsSleeping", false)
    local lastCF = handle:GetAttribute("_LastCF") or handle.CFrame
    local vel = (targetCF.Position - lastCF.Position) / dt
    if vel.Magnitude > speedlimit then
        vel = vel.Unit * speedlimit
        targetCF = lastCF.Rotation + (lastCF.Position + vel * dt)
    end
    handle:SetAttribute("_LastCF", targetCF)
    handle.CFrame = targetCF
    if HatReanimator.UsePatchmaLikeNetless then
        handle.AssemblyLinearVelocity = Vector3.new(vel.X*10, netless, vel.Z*10)
    else
        handle.AssemblyLinearVelocity = Vector3.new(vel.X, math.max(vel.Y, netless), vel.Z)
    end
    if spin then
        handle.AssemblyAngularVelocity = Vector3.new(16384,16384,16384)
    elseif HatReanimator.UseAngularVelocity then
        handle.AssemblyAngularVelocity = rvel + idle
    else
        handle.AssemblyAngularVelocity = idle
    end
    return true
end

-- æ°¸ä¹…æ­»äº¡
local function PermaDeath()
    if not replicatesignal then
        Util.Notify("âš ï¸ æ‰§è¡Œå™¨ä¸æ”¯æŒreplicatesignalï¼Œæ°¸ä¹…æ­»äº¡ä¸å¯ç”¨")
        return false
    end
    pcall(replicatesignal, Player.ConnectDiedSignalBackend)
    return true
end

-- æ›´æ–°å¸½å­ä½ç½®ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
local function UpdateHats(dt)
    if not HatReanimator.Enabled or not Player.Character then return end
    local hats = GetAllHats()
    HatReanimator.Hats = hats
    if #hats == 0 then return end

    -- è®¡ç®—èšé›†ä¸­å¿ƒï¼ˆé¼ æ ‡ä½ç½®æˆ–åŸä½ç½®ï¼‰
    local centerPos
    if HatReanimator.FollowMouse then
        local mousePos = UserInputService:GetMouseLocation()
        local ray = Camera:ScreenPointToRay(mousePos.X, mousePos.Y)
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.FilterDescendantsInstances = {Player.Character}
        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, params)
        centerPos = result and result.Position or (ray.Origin + ray.Direction * 500)
    else
        centerPos = HatReanimator.ClumpCenter or (Player.Character and Player.Character:GetPivot().Position) or Vector3.zero
    end
    local targetCF = CFrame.lookAt(centerPos, centerPos + Camera.CFrame.LookVector)

    -- å¤„ç†ç”©é£ç›®æ ‡
    local flingTarget = HatReanimator.FlingTargets[1]
    if flingTarget then
        if flingTarget.Time and os.clock() > flingTarget.Time then
            table.remove(HatReanimator.FlingTargets,1)
            flingTarget = nil
        elseif not flingTarget.Time then
            flingTarget.Time = os.clock() + (flingTarget.Duration or 2)
        end
    end

    for i, hat in ipairs(hats) do
        local handle = hat:FindFirstChild("Handle")
        if handle and handle:IsA("BasePart") then
            if flingTarget then
                -- ç”©é£æ¨¡å¼ï¼šé£å‘ç›®æ ‡
                local targPos = flingTarget.Target:GetPivot().Position
                local dir = (targPos - handle.Position).Unit
                local look = CFrame.lookAt(handle.Position, targPos)
                SetHatCFrameNetless(handle, dt, look, true)
            else
                -- æ™®é€šæ¨¡å¼ï¼šå›´ç»•ä¸­å¿ƒç‚¹æ—‹è½¬
                local radius = 2 + i*0.3
                local angle = (i / #hats) * math.pi*2 + os.clock()*0.8
                local offset = Vector3.new(math.cos(angle)*radius, math.sin(os.clock()*2)*0.5, math.sin(angle)*radius)
                local finalCF = targetCF * CFrame.new(offset)
                SetHatCFrameNetless(handle, dt, finalCF, false)
            end
        end
    end
end

function HatReanimator:Start()
    if self.Enabled then return end
    self.Enabled = true

    -- æ£€æŸ¥æ˜¯å¦æœ‰å¸½å­
    if #GetAllHats() == 0 then
        Util.Notify("âš ï¸ å½“å‰è§’è‰²æ²¡æœ‰ä½©æˆ´ä»»ä½•å¸½å­")
        self.Enabled = false
        return
    end

    -- æ°¸ä¹…æ­»äº¡
    if self.Permadeath then
        PermaDeath()
    end

    -- å¼ºåˆ¶æ‰€æœ‰å¸½å­æ‰è½
    for _,hat in ipairs(GetAllHats()) do
        SetAccoutrementState(hat, BackendAccoutrementState.InWorkspace)
        local handle = hat:FindFirstChild("Handle")
        if handle then
            handle.CanCollide = self.HatCollide
        end
    end

    -- å¯åŠ¨å¾ªç¯
    self.HeartbeatConn = RunService.Heartbeat:Connect(function(dt)
        UpdateHats(dt)
    end)

    Util.Notify("âœ… å¸½å­åˆ†èº«å·²å¯åŠ¨ï¼Œå…± "..#GetAllHats().." ä¸ªå¸½å­")
end

function HatReanimator:Stop()
    self.Enabled = false
    if self.HeartbeatConn then
        self.HeartbeatConn:Disconnect()
        self.HeartbeatConn = nil
    end
    -- æ¢å¤å¸½å­ï¼ˆå¯é€‰ï¼‰
    for _,hat in ipairs(GetAllHats()) do
        SetAccoutrementState(hat, BackendAccoutrementState.Equipped)
        local handle = hat:FindFirstChild("Handle")
        if handle then
            handle.CanCollide = false
        end
    end
    Util.Notify("â¹ å¸½å­åˆ†èº«å·²åœæ­¢")
end

function HatReanimator:Fling(target, duration)
    if not self.Enabled then
        Util.Notify("è¯·å…ˆå¯åŠ¨åˆ†èº«")
        return false
    end
    if typeof(target) == "Instance" and target:IsA("Model") then
        table.insert(self.FlingTargets, {Target=target, Duration=duration})
        Util.Notify("ğŸ¯ ç”©é£ç›®æ ‡: "..target.Name)
        return true
    end
    return false
end

function HatReanimator:ToggleCollide(state)
    self.HatCollide = state
    for _,hat in ipairs(GetAllHats()) do
        local handle = hat:FindFirstChild("Handle")
        if handle then handle.CanCollide = state end
    end
end

-- ========== ç»‘å®šUIæŒ‰é’® ==========
AddButton("â–¶ å¯åŠ¨å¸½å­åˆ†èº«", function()
    HatReanimator:Start()
end)
AddButton("â¹ åœæ­¢åˆ†èº«", function()
    HatReanimator:Stop()
end)
AddButton("ğŸ¯ ç”©é£é¼ æ ‡æŒ‡å‘ç›®æ ‡", function()
    local mouse = Player:GetMouse()
    if mouse.Target then
        local target = mouse.Target:FindFirstAncestorOfClass("Model") or mouse.Target.Parent
        if target then
            HatReanimator:Fling(target, 3)
        else
            Util.Notify("æœªæ‰¾åˆ°ç›®æ ‡æ¨¡å‹")
        end
    else
        Util.Notify("æ²¡æœ‰æŒ‡å‘ä»»ä½•ç‰©ä½“")
    end
end)
AddButton("ğŸ§¹ æ¸…é™¤ç”©é£ç›®æ ‡", function()
    table.clear(HatReanimator.FlingTargets)
    Util.Notify("ç”©é£é˜Ÿåˆ—å·²æ¸…ç©º")
end)

AddSwitch("ğŸ” å¯ç”¨ç¢°æ’", HatReanimator.HatCollide, function(s)
    HatReanimator:ToggleCollide(s)
end)
AddSwitch("ğŸ–± è·Ÿéšé¼ æ ‡", HatReanimator.FollowMouse, function(s)
    HatReanimator.FollowMouse = s
end)

-- Netlessé€Ÿåº¦è°ƒèŠ‚
local sliderContainer = Util.Instance("Frame", Content)
sliderContainer.Size = UDim2.new(1,-10,0,35)
sliderContainer.BackgroundTransparency = 1
local sliderLabel = Util.Instance("TextLabel", sliderContainer)
sliderLabel.AnchorPoint = Vector2.new(0,0.5)
sliderLabel.Position = UDim2.new(0,5,0.5,0)
sliderLabel.Size = UDim2.new(0.4,0,1,0)
sliderLabel.BackgroundTransparency = 1
sliderLabel.Text = "Netlessé€Ÿåº¦"
sliderLabel.TextColor3 = Color3.new(1,1,1)
sliderLabel.TextSize = 14
local sliderInput = Util.Instance("TextBox", sliderContainer)
sliderInput.AnchorPoint = Vector2.new(1,0.5)
sliderInput.Position = UDim2.new(1,-5,0.5,0)
sliderInput.Size = UDim2.new(0,60,0,25)
sliderInput.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
sliderInput.Text = tostring(HatReanimator.NetlessVelocity)
sliderInput.TextColor3 = Color3.new(1,1,1)
sliderInput.TextSize = 14
sliderInput.BorderSizePixel = 0
Util.Instance("UICorner", sliderInput).CornerRadius = UDim.new(0,4)
sliderInput.FocusLost:Connect(function()
    local n = tonumber(sliderInput.Text)
    if n then
        HatReanimator.NetlessVelocity = math.clamp(n, 20, 100)
        sliderInput.Text = tostring(HatReanimator.NetlessVelocity)
    else
        sliderInput.Text = tostring(HatReanimator.NetlessVelocity)
    end
end)

-- åˆå§‹æç¤º
Util.Notify("ğŸ© å¸½å­åˆ†èº«å·²åŠ è½½ï¼Œè¯·ç‚¹å‡»å¯åŠ¨")

-- æ˜¾ç¤ºUI
MainFrame.Visible = true
