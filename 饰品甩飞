--[[
    å¸½å­ç”©é£ & å¸½å­ç¢°æ’ç‹¬ç«‹æ¨¡å—
    åŸºäº Uhhhhhh Reanimate æå–ä¼˜åŒ–
    ç‰¹æ€§ï¼š
    - æ°¸ä¹…æ­»äº¡åè‡ªåŠ¨è·å–æ‰€æœ‰é¥°å“
    - å¯æ‹–åŠ¨/ç¼©æ”¾çš„ç‚«é…·æ§åˆ¶é¢æ¿
    - ä¸€é”®åˆ‡æ¢å¸½å­ç¢°æ’
    - é¼ æ ‡ç‚¹å‡»ç›®æ ‡ç”©é£
    - åˆ†èº«è·Ÿéšé¼ æ ‡ç§»åŠ¨
]]

if _G.HatFlingLoaded then return end
_G.HatFlingLoaded = true

-- ç¯å¢ƒå…¼å®¹
cloneref = cloneref or function(o) return o end
getcustomasset = getcustomasset or getsynasset
gethiddengui = gethiddengui or function() return cloneref(game:GetService("CoreGui")) end
isfile = isfile or function(p) local s,e=pcall(readfile,p); return s and e~=nil end
writefile = writefile or function(p,d) return end
delfile = delfile or function(p) return end
listfiles = listfiles or function(p) return {} end

-- æœåŠ¡
local Debris = cloneref(game:GetService("Debris"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local Players = cloneref(game:GetService("Players"))
local RunService = cloneref(game:GetService("RunService"))
local UserInputService = cloneref(game:GetService("UserInputService"))
local TweenService = cloneref(game:GetService("TweenService"))
local HttpService = cloneref(game:GetService("HttpService"))
local TextService = cloneref(game:GetService("TextService"))
local StarterGui = cloneref(game:GetService("StarterGui"))
local Camera = workspace.CurrentCamera

local Player = Players.LocalPlayer
local FallenPartsDestroyHeight = workspace.FallenPartsDestroyHeight or -500

-- ========== å·¥å…·å‡½æ•° ==========
local Util = {}
Util.RandomString = function(l)
	l = l or 16
	local s = ""
	for _=1,l do s = s .. string.char(math.random(32,126)) end
	return s
end
Util.Notify = function(t)
	StarterGui:SetCore("SendNotification", {Title="HatFling", Text=t, Duration=3})
end
Util.Instance = function(c,p)
	local i = Instance.new(c)
	i.Name = Util.RandomString()
	i.Parent = p
	return i
end
Util.GetScreenSize = function()
	return Camera and Camera.ViewportSize or Vector2.new(512,512)
end
Util.UDim2ToVector2Scale = function(u)
	return Vector2.new(u.X.Scale, u.Y.Scale)
end
Util.Vector2ToUDim2Scale = function(v)
	return UDim2.fromScale(v.X, v.Y)
end
Util.LinkDestroyI2I = function(a,b)
	a.Destroying:Once(function() b:Destroy() end)
end
Util.LinkDestroyI2C = function(a,b)
	a.Destroying:Once(function() b:Disconnect() end)
end
Util.IsGuiVisible = function(g)
	while g do
		if not g.Visible then return false end
		g = g.Parent
	end
	return true
end
Util.DeepcopyTable = function(t)
	local c = {}
	for k,v in pairs(t) do
		if type(v)=="table" then v=Util.DeepcopyTable(v) end
		c[k]=v
	end
	return c
end

-- ========== ç‚«é…·UIè¾…åŠ©ï¼ˆæ²¿ç”¨åŸUhhhhhhé£æ ¼ï¼‰ ==========
local HiddenGui = gethiddengui() or CoreGui
local ScreenGui = Util.Instance("ScreenGui", HiddenGui)
ScreenGui.Name = "HatFlingGUI"
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.DisplayOrder = 2147483647

local MainFrame = Util.Instance("Frame", ScreenGui)
MainFrame.AnchorPoint = Vector2.new(0.5,0.5)
MainFrame.Position = UDim2.new(0.5,0,0.5,0)
MainFrame.Size = UDim2.new(0,400,0,300)
MainFrame.BackgroundColor3 = Color3.new(0,0,0)
MainFrame.BorderSizePixel = 1
MainFrame.BorderColor3 = Color3.new(1,1,1)
local UICorner = Util.Instance("UICorner", MainFrame)
UICorner.CornerRadius = UDim.new(0,6)

-- æ‹–åŠ¨åŠŸèƒ½
local dragToggle,dragSpeed,dragStart,dragPos = nil,0.25, nil, nil
local function updateDrag(input)
	local delta = input.Position - dragStart
	local pos = UDim2.new(dragPos.X.Scale, dragPos.X.Offset + delta.X, dragPos.Y.Scale, dragPos.Y.Offset + delta.Y)
	MainFrame:TweenPosition(pos, Enum.EasingDirection.Out, Enum.EasingStyle.Linear, dragSpeed, true)
end
MainFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragToggle = true
		dragStart = input.Position
		dragPos = MainFrame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragToggle = false end
		end)
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if dragToggle and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		updateDrag(input)
	end
end)

-- ç¼©æ”¾åŠŸèƒ½ï¼ˆå³ä¸‹è§’æ‹–æ‹½ï¼‰
local resizeHandle = Util.Instance("Frame", MainFrame)
resizeHandle.AnchorPoint = Vector2.new(1,1)
resizeHandle.Position = UDim2.new(1,-10,1,-10)
resizeHandle.Size = UDim2.new(0,20,0,20)
resizeHandle.BackgroundColor3 = Color3.new(1,1,1)
resizeHandle.BackgroundTransparency = 0.5
resizeHandle.BorderSizePixel = 0
Util.Instance("UICorner", resizeHandle).CornerRadius = UDim.new(0,3)
local resizeStart, resizeSize
resizeHandle.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		resizeStart = input.Position
		resizeSize = MainFrame.Size
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if resizeStart and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local delta = input.Position - resizeStart
		local newWidth = math.max(200, resizeSize.X.Offset + delta.X)
		local newHeight = math.max(150, resizeSize.Y.Offset + delta.Y)
		MainFrame.Size = UDim2.new(0,newWidth,0,newHeight)
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if resizeStart and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
		resizeStart = nil
	end
end)

-- æ ‡é¢˜æ 
local TitleBar = Util.Instance("Frame", MainFrame)
TitleBar.Size = UDim2.new(1,0,0,30)
TitleBar.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
TitleBar.BorderSizePixel = 0
local TitleText = Util.Instance("TextLabel", TitleBar)
TitleText.AnchorPoint = Vector2.new(0,0.5)
TitleText.Position = UDim2.new(0,10,0.5,0)
TitleText.Size = UDim2.new(1,-40,1,0)
TitleText.BackgroundTransparency = 1
TitleText.Font = Enum.Font.GothamBold
TitleText.TextColor3 = Color3.new(1,1,1)
TitleText.TextSize = 18
TitleText.TextXAlignment = Enum.TextXAlignment.Left
TitleText.Text = "ğŸ© å¸½å­åˆ†èº«æ§åˆ¶"

-- å…³é—­æŒ‰é’®
local CloseBtn = Util.Instance("TextButton", TitleBar)
CloseBtn.AnchorPoint = Vector2.new(1,0.5)
CloseBtn.Position = UDim2.new(1,-10,0.5,0)
CloseBtn.Size = UDim2.new(0,20,0,20)
CloseBtn.BackgroundColor3 = Color3.new(1,0.3,0.3)
CloseBtn.Text = "X"
CloseBtn.TextColor3 = Color3.new(1,1,1)
CloseBtn.TextSize = 16
CloseBtn.BorderSizePixel = 0
Util.Instance("UICorner", CloseBtn).CornerRadius = UDim.new(0,3)
CloseBtn.MouseButton1Click:Connect(function() MainFrame.Visible = false end)

-- å†…å®¹åŒº
local Content = Util.Instance("Frame", MainFrame)
Content.AnchorPoint = Vector2.new(0.5,1)
Content.Position = UDim2.new(0.5,0,1,-5)
Content.Size = UDim2.new(1,-20,0,25)
Content.BackgroundColor3 = Color3.new(0.1,0.1,0.1)
Content.BorderSizePixel = 0
Util.Instance("UICorner", Content).CornerRadius = UDim.new(0,5)
Content.AutomaticSize = Enum.AutomaticSize.Y

local UIList = Util.Instance("UIListLayout", Content)
UIList.Padding = UDim.new(0,5)
UIList.FillDirection = Enum.FillDirection.Vertical
UIList.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIList.VerticalAlignment = Enum.VerticalAlignment.Top

local function AddButton(text, callback)
	local btn = Util.Instance("TextButton", Content)
	btn.Size = UDim2.new(1,-10,0,30)
	btn.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
	btn.Text = text
	btn.TextColor3 = Color3.new(1,1,1)
	btn.TextSize = 16
	btn.BorderSizePixel = 0
	Util.Instance("UICorner", btn).CornerRadius = UDim.new(0,4)
	btn.MouseButton1Click:Connect(callback)
	return btn
end
local function AddSwitch(text, default, callback)
	local container = Util.Instance("Frame", Content)
	container.Size = UDim2.new(1,-10,0,30)
	container.BackgroundTransparency = 1
	local lbl = Util.Instance("TextLabel", container)
	lbl.AnchorPoint = Vector2.new(0,0.5)
	lbl.Position = UDim2.new(0,5,0.5,0)
	lbl.Size = UDim2.new(0.7,0,1,0)
	lbl.BackgroundTransparency = 1
	lbl.Text = text
	lbl.TextColor3 = Color3.new(1,1,1)
	lbl.TextSize = 16
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	local sw = Util.Instance("TextButton", container)
	sw.AnchorPoint = Vector2.new(1,0.5)
	sw.Position = UDim2.new(1,-5,0.5,0)
	sw.Size = UDim2.new(0,50,0,25)
	sw.BackgroundColor3 = default and Color3.new(0,1,0) or Color3.new(0.5,0.5,0.5)
	sw.Text = default and "ON" or "OFF"
	sw.TextColor3 = Color3.new(1,1,1)
	sw.TextSize = 14
	sw.BorderSizePixel = 0
	Util.Instance("UICorner", sw).CornerRadius = UDim.new(0,4)
	local state = default
	sw.MouseButton1Click:Connect(function()
		state = not state
		sw.BackgroundColor3 = state and Color3.new(0,1,0) or Color3.new(0.5,0.5,0.5)
		sw.Text = state and "ON" or "OFF"
		callback(state)
	end)
	return state
end

-- ========== æ ¸å¿ƒå¸½å­é‡åŠ¨ç”»æ¨¡å— ==========
local HatReanimator = {
	Enabled = false,
	Hats = {},           -- å½“å‰æ§åˆ¶çš„å¸½å­ï¼ˆAccessoryå®ä¾‹ï¼‰
	FlingTargets = {},   -- ç”©é£ç›®æ ‡é˜Ÿåˆ—
	HatCollide = true,   -- å¯ç”¨ç¢°æ’
	Permadeath = true,   -- å¯ç”¨æ°¸ä¹…æ­»äº¡
	NetlessVelocity = 26,
	UseAngularVelocity = true,
	UsePatchmaLikeNetless = false,
	FollowMouse = true,  -- åˆ†èº«è·Ÿéšé¼ æ ‡
	ClumpCenter = nil,   -- å¸½å­èšé›†ä¸­å¿ƒï¼ˆCFrameï¼‰
}

-- è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯ç½‘ç»œæ‹¥æœ‰è€…
local function IsNetworkOwner(part)
	if isnetworkowner then
		local s,d = pcall(isnetworkowner, part)
		if s then return d end
	end
	return part.ReceiveAge == 0
end

-- è®¾ç½®AccoutrementçŠ¶æ€ï¼ˆéšè—/æ˜¾ç¤ºï¼‰
local BackendAccoutrementState = {None=0, HasHandle=1, InWorkspace=2, InCharacter=3, Equipped=4}
local function SetAccoutrementState(acc, state)
	if sethiddenproperty then
		sethiddenproperty(acc, "BackendAccoutrementState", state)
	else
		pcall(function() acc.BackendAccoutrementState = state end)
	end
end

-- è·å–æ‰€æœ‰å¸½å­ï¼ˆAccessoryï¼‰
local function GetAllHats()
	local hats = {}
	local char = Player.Character
	if char then
		for _,v in ipairs(char:GetChildren()) do
			if v:IsA("Accessory") then
				table.insert(hats, v)
			end
		end
	end
	return hats
end

-- è®¾ç½®å¸½å­ç½‘ç»œæ§åˆ¶ï¼ˆæ ¸å¿ƒnetlessç§»åŠ¨ï¼‰
local function SetHatCFrameNetless(handle, dt, targetCF, spin)
	if not (handle and handle:IsA("BasePart") and handle:IsDescendantOf(workspace)) then return false end
	if dt <= 0 then return false end
	local timing = os.clock()
	local idle = Vector3.new(math.sin(timing*14), math.sin(timing*15+1.0472), math.sin(timing*16+2.0944)) * 0.001
	if targetCF.Y < FallenPartsDestroyHeight+5 then
		targetCF = targetCF + Vector3.new(0, FallenPartsDestroyHeight+5 - targetCF.Y, 0)
	end
	local speedlimit = 16384
	local netless = HatReanimator.NetlessVelocity
	if not IsNetworkOwner(handle) then return false end
	pcall(sethiddenproperty, handle, "NetworkIsSleeping", false)
	local lastCF = handle:GetAttribute("_LastCF") or handle.CFrame
	local vel = (targetCF.Position - lastCF.Position) / dt
	if vel.Magnitude > speedlimit then
		vel = vel.Unit * speedlimit
		targetCF = lastCF.Rotation + (lastCF.Position + vel * dt)
	end
	local rvel = lastCF:ToObjectSpace(targetCF)
	local a,b = rvel:ToAxisAngle()
	rvel = (a * b) / dt
	handle:SetAttribute("_LastCF", targetCF)
	handle.CFrame = targetCF
	if HatReanimator.UsePatchmaLikeNetless then
		handle.AssemblyLinearVelocity = Vector3.new(vel.X*10, netless, vel.Z*10)
	else
		handle.AssemblyLinearVelocity = Vector3.new(vel.X, math.max(vel.Y, netless), vel.Z)
	end
	if spin then
		handle.AssemblyAngularVelocity = Vector3.new(16384,16384,16384)
	elseif HatReanimator.UseAngularVelocity then
		handle.AssemblyAngularVelocity = rvel + idle
	else
		handle.AssemblyAngularVelocity = idle
	end
	return true
end

-- æ°¸ä¹…æ­»äº¡è§¦å‘
local function PermaDeath()
	if not replicatesignal then
		Util.Notify("executorä¸æ”¯æŒreplicatesignalï¼Œæ— æ³•æ°¸ä¹…æ­»äº¡")
		return false
	end
	replicatesignal(Player.ConnectDiedSignalBackend)
	return true
end

-- æ›´æ–°æ‰€æœ‰å¸½å­ä½ç½®
local function UpdateHats(dt)
	if not HatReanimator.Enabled or not Player.Character then return end
	-- è·å–å½“å‰æ‰€æœ‰å¸½å­
	local hats = GetAllHats()
	HatReanimator.Hats = hats
	if #hats == 0 then return end

	-- è®¡ç®—èšé›†ä¸­å¿ƒ
	local centerPos
	if HatReanimator.FollowMouse then
		local mousePos = UserInputService:GetMouseLocation()
		local ray = Camera:ScreenPointToRay(mousePos.X, mousePos.Y)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Blacklist
		params.FilterDescendantsInstances = {Player.Character}
		local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, params)
		if result then
			centerPos = result.Position
		else
			centerPos = ray.Origin + ray.Direction * 500
		end
	else
		centerPos = HatReanimator.ClumpCenter or (Player.Character and Player.Character:GetPivot().Position) or Vector3.zero
	end
	local targetCF = CFrame.lookAt(centerPos, centerPos + Camera.CFrame.LookVector)

	-- å¤„ç†ç”©é£ç›®æ ‡
	local flingTarget = HatReanimator.FlingTargets[1]
	if flingTarget then
		if flingTarget.Time and os.clock() > flingTarget.Time then
			table.remove(HatReanimator.FlingTargets,1)
			flingTarget = nil
		elseif not flingTarget.Time then
			flingTarget.Time = os.clock() + (flingTarget.Duration or 2)
		end
	end

	for _,hat in ipairs(hats) do
		local handle = hat:FindFirstChild("Handle")
		if handle and handle:IsA("BasePart") then
			if flingTarget then
				-- ç”©é£æ¨¡å¼ï¼šæ‰€æœ‰å¸½å­é£å‘ç›®æ ‡
				local targCF = CFrame.lookAt(handle.Position, flingTarget.Target:GetPivot().Position)
				SetHatCFrameNetless(handle, dt, targCF, true)
			else
				-- æ™®é€šæ¨¡å¼ï¼šå¸½å­èšé›†åˆ°ä¸­å¿ƒç‚¹ï¼Œæ’åˆ—æˆç¯
				local index = 0 for i,h in ipairs(hats) do if h==hat then index=i break end end
				local radius = 2 + index*0.5
				local angle = (index / #hats) * math.pi*2 + os.clock()*0.5
				local offset = Vector3.new(math.cos(angle)*radius, math.sin(os.clock()*2)*0.5, math.sin(angle)*radius)
				local finalCF = targetCF * CFrame.new(offset)
				SetHatCFrameNetless(handle, dt, finalCF, false)
			end
		end
	end
end

-- å¯åŠ¨é‡åŠ¨ç”»
function HatReanimator:Start()
	if self.Enabled then return end
	self.Enabled = true

	-- æ°¸ä¹…æ­»äº¡
	if self.Permadeath then
		PermaDeath()
	end

	-- å¼ºåˆ¶æ‰€æœ‰å¸½å­æ‰è½ï¼ˆé€šè¿‡è®¾ç½®çŠ¶æ€ï¼‰
	for _,hat in ipairs(GetAllHats()) do
		SetAccoutrementState(hat, BackendAccoutrementState.InWorkspace)
		local handle = hat:FindFirstChild("Handle")
		if handle then
			handle.CanCollide = self.HatCollide
		end
	end

	-- å¯åŠ¨æ›´æ–°å¾ªç¯
	self.HeartbeatConn = RunService.Heartbeat:Connect(function(dt)
		UpdateHats(dt)
	end)

	Util.Notify("å¸½å­åˆ†èº«å·²æ¿€æ´»")
end

-- åœæ­¢é‡åŠ¨ç”»
function HatReanimator:Stop()
	self.Enabled = false
	if self.HeartbeatConn then
		self.HeartbeatConn:Disconnect()
		self.HeartbeatConn = nil
	end
	-- æ¢å¤å¸½å­çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
	for _,hat in ipairs(GetAllHats()) do
		SetAccoutrementState(hat, BackendAccoutrementState.Equipped)
		local handle = hat:FindFirstChild("Handle")
		if handle then
			handle.CanCollide = false
		end
	end
	Util.Notify("å¸½å­åˆ†èº«å·²åœæ­¢")
end

-- ç”©é£æŒ‡å®šç›®æ ‡
function HatReanimator:Fling(target, duration)
	if not self.Enabled then return false end
	if typeof(target) == "Instance" and target:IsA("Model") then
		table.insert(self.FlingTargets, {Target=target, Duration=duration})
		return true
	end
	return false
end

-- åˆ‡æ¢ç¢°æ’
function HatReanimator:ToggleCollide(state)
	self.HatCollide = state
	for _,hat in ipairs(GetAllHats()) do
		local handle = hat:FindFirstChild("Handle")
		if handle then
			handle.CanCollide = state
		end
	end
end

-- ========== UIæ§åˆ¶ ==========
AddButton("ğŸ© å¯åŠ¨å¸½å­åˆ†èº«", function()
	HatReanimator:Start()
end)

AddButton("â¹ åœæ­¢åˆ†èº«", function()
	HatReanimator:Stop()
end)

AddButton("ğŸ¯ ç”©é£é¼ æ ‡æŒ‡å‘ç›®æ ‡", function()
	local mouse = Player:GetMouse()
	if mouse.Target then
		local target = mouse.Target:FindFirstAncestorOfClass("Model") or mouse.Target.Parent
		if target then
			HatReanimator:Fling(target, 3)
			Util.Notify("ç”©é£ç›®æ ‡: "..target.Name)
		end
	end
end)

AddButton("ğŸ§¹ æ¸…é™¤æ‰€æœ‰ç”©é£ç›®æ ‡", function()
	table.clear(HatReanimator.FlingTargets)
	Util.Notify("ç”©é£é˜Ÿåˆ—å·²æ¸…ç©º")
end)

AddSwitch("ğŸ” å¯ç”¨ç¢°æ’", HatReanimator.HatCollide, function(state)
	HatReanimator:ToggleCollide(state)
end)

AddSwitch("ğŸ–± è·Ÿéšé¼ æ ‡", HatReanimator.FollowMouse, function(state)
	HatReanimator.FollowMouse = state
end)

-- å¯é€‰çš„netlessè°ƒèŠ‚æ»‘å—
local sliderContainer = Util.Instance("Frame", Content)
sliderContainer.Size = UDim2.new(1,-10,0,30)
sliderContainer.BackgroundTransparency = 1
local sliderLabel = Util.Instance("TextLabel", sliderContainer)
sliderLabel.AnchorPoint = Vector2.new(0,0.5)
sliderLabel.Position = UDim2.new(0,5,0.5,0)
sliderLabel.Size = UDim2.new(0.4,0,1,0)
sliderLabel.BackgroundTransparency = 1
sliderLabel.Text = "Netlessé€Ÿåº¦"
sliderLabel.TextColor3 = Color3.new(1,1,1)
sliderLabel.TextSize = 14
local sliderVal = Util.Instance("TextBox", sliderContainer)
sliderVal.AnchorPoint = Vector2.new(1,0.5)
sliderVal.Position = UDim2.new(1,-5,0.5,0)
sliderVal.Size = UDim2.new(0,50,0,25)
sliderVal.BackgroundColor3 = Color3.new(0.3,0.3,0.3)
sliderVal.Text = tostring(HatReanimator.NetlessVelocity)
sliderVal.TextColor3 = Color3.new(1,1,1)
sliderVal.TextSize = 14
sliderVal.BorderSizePixel = 0
Util.Instance("UICorner", sliderVal).CornerRadius = UDim.new(0,4)
sliderVal.FocusLost:Connect(function()
	local n = tonumber(sliderVal.Text)
	if n then
		HatReanimator.NetlessVelocity = math.clamp(n, 20, 100)
		sliderVal.Text = tostring(HatReanimator.NetlessVelocity)
	end
end)

-- æ³¨æ„ï¼šéƒ¨åˆ†é«˜çº§åŠŸèƒ½ï¼ˆå¦‚æ°¸ä¹…æ­»äº¡ï¼‰å¯èƒ½ä¾èµ–replicatesignalï¼Œè‹¥ä¸æ”¯æŒåˆ™è‡ªåŠ¨é™çº§
if not replicatesignal then
	Util.Notify("å½“å‰executorä¸æ”¯æŒæ°¸ä¹…æ­»äº¡ï¼Œéƒ¨åˆ†åŠŸèƒ½å—é™")
	HatReanimator.Permadeath = false
end

-- åˆå§‹éšè—UIï¼ˆå¯æŒ‰éœ€æ˜¾ç¤ºï¼‰
MainFrame.Visible = true

-- ========== ä½¿ç”¨è¯´æ˜ ==========
Util.Notify("ğŸ© å¸½å­åˆ†èº«å·²åŠ è½½ï¼Œæ‹–åŠ¨/ç¼©æ”¾çª—å£ï¼Œç‚¹å‡»å¯åŠ¨")
